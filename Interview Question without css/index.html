<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python DSA Interview Questions</title>
    
</head>
<body>
    <article>
        <header>
            <h1>Python DSA Interview Questions</h1>
            <p><em>A collection of commonly asked data structures and algorithms interview questions in Python.</em></p>
        </header>
        
        <details>
            <summary>1. How do you find the missing number in a given integer array of 1 to N?</summary>
            <p>You can find the missing number using the sum formula:</p>
            <pre>
                def find_missing_number(arr, n):
                    total = n * (n + 1) // 2
                    return total - sum(arr)
                
                print(find_missing_number([1, 2, 4, 5, 6], 6))  # Output: 3
            </pre>
        </details>
        
        <details>
            <summary>2. How do you reverse an array in Python?</summary>
            <p>You can use slicing or the reverse method:</p>
            <pre>
                def reverse_array(arr):
                    return arr[::-1]
                
                print(reverse_array([1, 2, 3, 4, 5]))  # Output: [5, 4, 3, 2, 1]
            </pre>
        </details>
        
        <details>
            <summary>3. How do you find the largest and smallest number in an array?</summary>
            <p>Using Python's built-in functions:</p>
            <pre>
                def find_min_max(arr):
                    return min(arr), max(arr)
                
                print(find_min_max([3, 1, 5, 7, 9, 2]))  # Output: (1, 9)
            </pre>
        </details>
        
        <details>
            <summary>4. How do you find the second largest number in an array?</summary>
            <p>Sorting the array or using a single pass:</p>
            <pre>
                def second_largest(arr):
                    first, second = float('-inf'), float('-inf')
                    for num in arr:
                        if num > first:
                            second = first
                            first = num
                        elif num > second and num != first:
                            second = num
                    return second
                
                print(second_largest([3, 1, 5, 7, 9, 2]))  # Output: 7
            </pre>
        </details>
        
        <details>
            <summary>5. How do you rotate an array to the right by K steps?</summary>
            <p>Using slicing:</p>
            <pre>
                def rotate_array(arr, k):
                    k %= len(arr)
                    return arr[-k:] + arr[:-k]
                
                print(rotate_array([1, 2, 3, 4, 5], 2))  # Output: [4, 5, 1, 2, 3]
            </pre>
        </details>
    </section>
        
    <section>
        <h2>Linked List Questions</h2>
        <details>
            <summary>1. How do you detect a cycle in a linked list?</summary>
            <p>You can use Floydâ€™s Cycle Detection Algorithm:</p>
            <pre>
                class ListNode:
                    def __init__(self, val=0, next=None):
                        self.val = val
                        self.next = next
                
                def has_cycle(head):
                    slow, fast = head, head
                    while fast and fast.next:
                        slow = slow.next
                        fast = fast.next.next
                        if slow == fast:
                            return True
                    return False
            </pre>
        </details>
        
        <details>
            <summary>2. How do you find the middle of a linked list?</summary>
            <p>Using the slow and fast pointer approach:</p>
            <pre>
                def find_middle(head):
                    slow, fast = head, head
                    while fast and fast.next:
                        slow = slow.next
                        fast = fast.next.next
                    return slow
            </pre>
        </details>
        
        <details>
            <summary>3. How do you reverse a linked list?</summary>
            <p>Using iterative or recursive approach:</p>
            <pre>
                def reverse_linked_list(head):
                    prev, curr = None, head
                    while curr:
                        nxt = curr.next
                        curr.next = prev
                        prev = curr
                        curr = nxt
                    return prev
            </pre>
        </details>
    </section>
        
    <section>
        <h2>Sorting and Searching</h2>
        <details>
            <summary>1. How do you implement binary search?</summary>
            <p>Binary search works by repeatedly dividing the search interval in half:</p>
            <pre>
                def binary_search(arr, target):
                    left, right = 0, len(arr) - 1
                    while left <= right:
                        mid = (left + right) // 2
                        if arr[mid] == target:
                            return mid
                        elif arr[mid] < target:
                            left = mid + 1
                        else:
                            right = mid - 1
                    return -1
                
                print(binary_search([1, 2, 3, 4, 5], 3))  # Output: 2
            </pre>
        </details>
        
        <details>
            <summary>2. How do you implement quicksort?</summary>
            <p>Quicksort is a divide-and-conquer algorithm:</p>
            <pre>
                def quicksort(arr):
                    if len(arr) <= 1:
                        return arr
                    pivot = arr[len(arr) // 2]
                    left = [x for x in arr if x < pivot]
                    middle = [x for x in arr if x == pivot]
                    right = [x for x in arr if x > pivot]
                    return quicksort(left) + middle + quicksort(right)
                
                print(quicksort([3, 6, 8, 10, 1, 2, 1]))
            </pre>
        </details>
    </section>
        
        <section>
            <h2>Dynamic Programming</h2>
            
            <details>
                <summary>1. How do you solve the Fibonacci sequence using dynamic programming?</summary>
                <p>Using memoization or bottom-up approach:</p>
                <pre>
                    def fibonacci(n, memo={}):
                        if n in memo:
                            return memo[n]
                        if n <= 1:
                            return n
                        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
                        return memo[n]
                    
                    print(fibonacci(10))  # Output: 55
                </pre>
            </details>
            
            <details>
                <summary>2. How do you solve the longest common subsequence problem?</summary>
                <p>Using dynamic programming with a 2D table:</p>
                <pre>
                    def lcs(X, Y):
                        m, n = len(X), len(Y)
                        dp = [[0] * (n + 1) for _ in range(m + 1)]
                        
                        for i in range(1, m + 1):
                            for j in range(1, n + 1):
                                if X[i - 1] == Y[j - 1]:
                                    dp[i][j] = dp[i - 1][j - 1] + 1
                                else:
                                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                        return dp[m][n]
                    
                    print(lcs("abcde", "ace"))  # Output: 3
                </pre>
            </details>
        </section>
        
        <section>
            <h2>Graph Algorithms</h2>
            <details>
                <summary>1. How do you implement Depth-First Search (DFS)?</summary>
                <p>DFS uses recursion or a stack to explore nodes:</p>
                <pre>
                    def dfs(graph, node, visited=set()):
                        if node not in visited:
                            print(node)
                            visited.add(node)
                            for neighbor in graph[node]:
                                dfs(graph, neighbor, visited)
                    
                    graph = {
                        'A': ['B', 'C'],
                        'B': ['D', 'E'],
                        'C': ['F'],
                        'D': [],
                        'E': ['F'],
                        'F': []
                    }
                    
                    dfs(graph, 'A')
                </pre>
            </details>
            <details>
                <summary>2. How do you find the shortest path in an unweighted graph?</summary>
                <p>Using Breadth-First Search (BFS):</p>
                <pre>
                    from collections import deque
                    
                    def shortest_path(graph, start, end):
                        queue = deque([(start, [start])])
                        visited = set()
                        
                        while queue:
                            node, path = queue.popleft()
                            if node == end:
                                return path
                            if node not in visited:
                                visited.add(node)
                                for neighbor in graph[node]:
                                    queue.append((neighbor, path + [neighbor]))
                    
                    graph = {
                        'A': ['B', 'C'],
                        'B': ['D', 'E'],
                        'C': ['F'],
                        'D': [],
                        'E': ['F'],
                        'F': []
                    }
                    
                    print(shortest_path(graph, 'A', 'F'))  # Output: ['A', 'C', 'F']
                </pre>
            </details>
        </section>
        
        <section>
            <h2>String Manipulation</h2>
            <details>
                <summary>1. How do you check if a string is a palindrome?</summary>
                <p>A string is a palindrome if it reads the same forward and backward:</p>
                <pre>
                    def is_palindrome(s):
                        return s == s[::-1]
                    
                    print(is_palindrome("racecar"))  # Output: True
                </pre>
            </details>
            
            <details>
                <summary>2. How do you count the number of vowels in a string?</summary>
                <p>Using a simple loop:</p>
                <pre>
                    def count_vowels(s):
                        return sum(1 for char in s.lower() if char in "aeiou")
                    
                    print(count_vowels("Hello World"))  # Output: 3
                </pre>
            </details>
            <details>
                <summary>3. How do you find the longest substring without repeating characters?</summary>
                <p>Using the sliding window technique:</p>
                <pre>
                    def longest_unique_substring(s):
                        char_index = {}
                        left = max_length = 0
                        
                        for right in range(len(s)):
                            if s[right] in char_index:
                                left = max(left, char_index[s[right]] + 1)
                            char_index[s[right]] = right
                            max_length = max(max_length, right - left + 1)
                        
                        return max_length
                    
                    print(longest_unique_substring("abcabcbb"))  # Output: 3
                </pre>
            </details>
        </section>
        
        <footer>
            <p><strong>Note:</strong> These questions are commonly asked in Python DSA interviews. Keep practicing to strengthen your problem-solving skills!</p>
        </footer>
    </article>
</body>
</html>
